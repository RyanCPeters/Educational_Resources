Lecture 2-26: Modeling Computation
===

Created By: [Yusuf Pisan](http://courses.washington.edu/css343/pisan/)
---

formatted to Github Markdown syntax by Ryan Peters

#### Be sure to check the other lectures out after you finish this one! 

<div><a href="https://ryancpeters.github.io/Educational_Resources/343/lecture3/" style="position: relative; left: 5em">Previous lecture </a><a href="https://ryancpeters.github.io/Educational_Resources/343/lecture5/" style="position: relative; left: 20em">Next lecture</a></div>


[1]:#lecture-4-binary-heaps--graphs "Back to Table of Contents"

---

#### Table of Contents
Table of Contents
1. Modeling Computation
2. Modeling Computation(2)
3. English
4. Grammar
5. Exercise: Grammar (1)
6. Exercise (2)
7. Exercise (3)
8. Exercise (4)
9. Exercise (5)
10. Types of Phrase-Structure Grammars
11. Derivation Tree
12. Backus–Naur Form
13. Exercise: BNF
14. Finite-State Machines with Output
15. FSM with Output
16. Exercise: FSM state table to diagram
17. Exercise: FSM diagram to state table
18. Exercise: FSM diagram to signal error
19. Finite State Automota (FSM with no output)
20. NonDeterministic FSA
21. Language Recognition
22. Exercise: Regular expressions
23. FSA Limitations
24. Turing Machine
25. Turing Machine Working
26. The Church–Turing Thesis
27. Computational Complexity, Computability, and Decidability
28. Halting Problem


---
2 computation context description 
---

Can a task be carried out by a computer? If so, how can it be carried out?

Models of computation help answer these questions:

- Grammars
    - Programming Languages (Java, C, ...)
    - Natural Languages (English, French, ...)

- Finite State Machines
    - Set ot states, start state, an input alphabet, transition function
    - Limited memory (fixed number of states)
    - May have an output
    - Can be used to recognize a language

- Turing Machines
    - Church-Turing Thesis: Every computation can be carried out uising a Turing machine
    - Using Turing machines to classify tracktable/untractable and solvable/unsolvable problems

Reference: Rosen, Chapter 13



---
3 English
---


- Syntax - follows the rules of the Language

- Semantics - makes sense (requires contextual knowledge)


<font size=5>
1. a *sentence* is made up of a *noun phrase* followed by a *verb phrase*;  
2. a *noun phrase* is made up of an *article* followed by an *adjective* followed by a *noun*,  
or  
3. a *noun phrase* is made up of an *article* followed by a *noun*;  
4. a *verb phrase* is made up of a *verb* followed by an *adverb*, or  
5. a *verb phrase* is made up of a *verb*;  
6-7. an *article* is a, or the  
8-9. an *adjective* is large, or hungry;  
10-11. a *noun* is rabbit, or mathematician;  
12-13. a *verb* is eats, or hops;  
14. an *adverb* is quickly, or wildly.  
</font>

Example: the large rabbit hops quickly

What is the noun phrase? What is the verb phrase?


---
4 Grammar
---


A vocabulary (or alphabet) V is a finite, nonempty set of elements called symbols.A word (or sentence) over V is a string of finite length of elements of V . The empty string or null string, denoted by λ (lambda), is the string containing no symbols. The set of all words over V is denoted by V\* A language over V is a subset of V\*

How do we specify a language?

- List all possible words

- Provide criteria to be in the language

<font size=5>
Grammar provides a set of symbols and rules for producing words
Some of the elements cannot be replaced by anything, they are terminals
Some elements can be replaced, nonterminals
Special member of the vocabulary called the start symbol
The rules that specify when we can replace a string from V\*, productions, such as S → NP VP
</font>

A *phrase-structure grammar* G = (V, T, S, P)  
V: Vocabulary  
T: Terminals  
S: Start symbol  
P: Finite set of productions  


---
5 Exercise: Grammar (1)
---


G = (V, T, S, P), where V = {a, b, A, B, S}, T = {a, b}, S is the start symbol, and P = {S → ABa, A → BB, B → ab, AB → b}.

What words are valid?

ba (from S → ABa, AB → b, we endup with ba)
ababa ?
abababa ?
abbabbaba ?

The language generated by G (or the language of G), denoted by L(G)


---
6 Exercise (2)
---


For G with the grammar with vocabulary V = {S, A, a, b}, set of terminals T = {a, b}, starting symbol S, and productions P = {S → aA, S → b, A → aa}. What is L(G), the language of this grammar?

>- L(G) = {b, aaa}



---
7 Exercise (3)
---


Let G be the grammar with vocabulary V = {S, 0, 1}, set of terminals T = {0, 1}, starting symbol S, and productions P = {S → 11S, S → 0}. What is L(G), the language of this grammar?

>- L(G) = {0, 110, 11110, 1111110, . . . }, the set of all strings that begin with an even number of 1s and end with a 0



---
8 Exercise (4)
---


Give a phrase-structure grammar that generates the set {0n1n | n = 0, 1, 2, . . . }.

Should be able to produce 01, 0011, 000111, 00001111, …

>- S → 0S1
>- S → λ


---
9 Exercise (5)
---


G = (V, T, S, P) with V = {0, 1, 2, S,A,B,C}; T = {0, 1, 2}; starting state S; and productions

S → λ
S → C
C → 0CAB
BA → AB
0A → 01
1A → 11
1B → 12
2B → 22

What is L(G), the language of this grammar?

>-  L(G) = {0<sup>n</sup>1<sup>n</sup>2<sup>n</sup> | n = 0, 1, 2, 3, . . . }



---
10 Types of Phrase-Structure Grammars
---


Scheme introduced by Noam Chomsky

**type 0** - no restrictions on its productions

**type 1** - grammar can have productions of the form w~1~ â†’ w~2~, where w~1~ = lAr and w~2~ = lwr, where A is a nonterminal symbol, l and r are strings of zero or more terminal or nonterminal symbols, and w is a nonempty
string of terminal or nonterminal symbols. It can also have the production S â†’ Î» as long
as S does not appear on the right-hand side of any other production. 

**type 2** - productions only of the form w~1~ â†’ w~2~, where w~1~ is a single symbol that is not a terminal
symbol

**type 3** - productions only of the form w~1~ â†’ w~2~ with w~1~ = A and either w~2~ = aB or w~2~ = a, where A and B are nonterminal symbols


- Type 1 grammars are called *context sensitive*. If we have a rule, lw~1~r â†’ lw~2~r, w~1~ can be replaced by w~2~ only when it is surrounded by the strings l and r. 


- Type 2 grammars are called *context-free grammars*. The language they generate is called *context-free language*

- Type 3 grammars are called *regular grammars*. The language they generate is called *regular*



---
11 Derivation Tree
---


Derivation tree for: the hungry rabbit eats quickly

![](../images/rosen13-derivation-tree.png)

<font size=5>
1. a *sentence* is made up of a *noun phrase* followed by a *verb phrase*;  
2. a *noun phrase* is made up of an *article* followed by an *adjective* followed by a *noun*,  
or  
3. a *noun phrase* is made up of an *article* followed by a *noun*;  
4. a *verb phrase* is made up of a *verb* followed by an *adverb*, or  
5. a *verb phrase* is made up of a *verb*;  
6-7. an *article* is a, or the  
8-9. an *adjective* is large, or hungry;  
10-11. a *noun* is rabbit, or mathematician;  
12-13. a *verb* is eats, or hops;  
14. an *adverb* is quickly, or wildly.  
</font>

Construct the derivation trees for:

- the mathematician hops

- the mathematician hops wildly

- a hungry mathemetician hops wildly



---
12 Backus-Naur Form
---


Backus-Naur form (BNF), after John Backus, who invented it, and Peter Naur, who refined it

Fun Fact: a notation quite similar to the BNF was used approximately 2500 years ago to describe the grammar of Sanskrit.

- Type-2 (Context-Free Grammars) have a single nonterminal symbol as their left-hand side, combine all those with the same nonterminal symbol on the left-hand side into one statement. 

- Instead of â†’ use ::=

- Enclose all nonterminal symbols in brackets, < > 	

- List all the right-hand sides of productions in the same statement, separating them by bars.

\<identifier\>	 ::= \<letter\>	 |\<identifier\>	\<letter\> | \<identifier\>	\<digit\>  	
\<letter\>	 ::= a | b | Â· Â· Â· | y | z   
\<digit\>	 ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

Defining a variable


---
13 Exercise: BNF
---


Give the Backusâ€“Naur form for the production of signed integers in decimal notation. (A signed
integer is a nonnegative integer preceded by a plus sign or a minus sign.)

>- \<signed integer\>	 ::= \<sign\>	\<integer\>  
>- \<sign\>	 ::= + | âˆ’  
>- \<integer\>	 ::= \<digit	 | \<digit	\<integer	  
>- \<digit\>	 ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9  



---
14 Finite-State Machines with Output
---


FSM are used in spell-checking, grammer checking, indexing, recognizing speech, markup languages (HTML. XML), network protocols and so on

![](../images/rosen13-state-machine-table.png)

When 30 cents has been deposited and any excess refunded, the cutomer can push a button

O (Orange juice button), R (Red apple juice button), n (no output)

<font size=5>
A student puts in a dime followed by a quarter, receives 5 cents back, and then pushes the orange button
for an orange juice. The machine starts in state s0. The first input is 10 cents, which changes
the state of the machine to s2 and gives no output. The second input is 25 cents. This changes
the state from s2 to s6, and gives 5 cents as output. The next input is the orange button, which
changes the state from s6 back to s0 (because the machine returns to the start state) and gives
an orange juice as its output

</font>


---
15 FSM with Output
---


Diagram for vending machine

![](../images/rosen13-state-machine-diagram.png)


---
16 Exercise: FSM state table to diagram
---


![](../images/rosen13-example3-table.png)



---
17 Exercise: FSM diagram to state table
---


![](../images/rosen13-example3-2-diagram.png)


What is the output string generated if the input string is 101011?



---
18 Exercise: FSM diagram to signal error
---


In a certain coding scheme, when three consecutive 1s appear in a message, the receiver of the
message knows that there has been a transmission error. Construct a finite-state machine that
gives a 1 as its current output bit if and only if the last three bits received are all 1s.



---
19 Finite State Automota (FSM with no output)
---


No output, and have final states to indicate if the input is acceptable or not

![](../images/rosen13-3-fsa.png)

What strings of input are acceptable for this FSA?

000000 ?  
1010101 ?  
000111001100 ?  
1101101101101 ?  

Exercises:  

- the set of bit strings that begin with two 0s
- the set of bit strings that contain two consecutive 0s
- the set of bit strings that do not contain two consecutive 0s
- the set of bit strings that end with two 0s
- the set of bit strings that contain at least two 0s


---
20 NonDeterministic FSA
---


Given the same input, a state can transition to multiple states

![](../images/rosen13-3-ex10-nonfsa.png)


---
21 Language Recognition
---


Kleen (1956) showed that there is a FSA that recognizes a set if and only if this set can be built
up from the null set, the empty string, and singleton strings by taking concatenations, unions,
and Kleene closures, in arbitrary order. 

The Kleene closure of A is the concatenation of A with itself an arbitrary
finite number of times, empty or A, AA, AAA, AAAA, ...

Sets that can be built up in this way are called regular sets. automaton. To
define regular sets we first need to define regular expressions.

A regular expression:

- Î» (lambda), an empty string

- any character in language

- Given X and Y are regular expressions. The order of precedence is: (X), X*, XY, X|Y


---
22 Exercise: Regular expressions
---

What string are produced

1. 10\*

2. (10)\*

3. 0 | 01

4. 0 (0 | 1)\*

5.  (0\*1)\*


> 1. a 1 followed by any number of 0s (including no zeros)
> 2. any number of copies of 10 (including the null string)
> 3. the string 0 or the string 01
> 4. any string beginning with 0
> 5. any string not ending with 0



---
23 FSA Limitations
---


Can we build an FSA to recognize the language {0^n^1^n^ | n = 0, 1, 2, . . . } ?

Pushdown Automota: FSA plus a stack which provides unlimited memory

But, pushdown automota cannot represent {0^n^1^n^2^n | n = 0, 1, 2, . . . }, The stack can be used to show that we have the smae number of 0s and 1s, but once shown the stack is empty and cannot verify the corect number of 2s.

Linear bounded automata can recognize 0^n^1^n^2^n, but still not all context-sesitive languages


---
24 Turing Machine
---


- control unit, which at any step is in one of finitely many different states, 

- a tape divided into cells, which is infinite in both directions.

Turing machines have read and write capabilities on the tape as the control unit moves back and
forth along this tape, changing states depending on the tape symbol read.


- Turing machines have memory (FSA don't)

- Most general models of computation

- More powerful than real computers which have finite memory

**All Turing machines are equivalent in power**

- multiple tapes
- multi-dimensional tapes
- multiple tape heads that read different cells simultaneously
- to be nondeterministic
- restrict the tape to be infinite in only one dimension
- restrict the tape alphabet to have only two symbols.


---
25 Turing Machine Working
---


Assumed to be in the initial state s0 and to be positioned over the leftmost nonblank symbol

Turing machine ddefined by 5-tuples:
<font size=5>
1. (s0, 0, s0, 0,R) 2. (s0, 1, s1, 1,R) 3. (s0,B, s3,B,R) 4. (s1, 0, s0, 0,R)
5. (s1, 1, s2, 0,L)  6. (s1,B, s3,B,R)  7. (s2, 1, s3, 0,R)
</font>

Changes the first pair of consecutive 1s on the tape to 0s and then halts

<table>
<tr>
<td>![](../images/rosen13-turing.png)</td>
<td>
<font size=6>
a. Using 1: at s0, read 0, stay in state s0, write 0, move Right  
b. Usign 2: at s0, read 1, enter state s1, write 1, move Right  
c. Using 4: at s1, read 0, enter state s0, write 0, move Right  
d. Using 2: at s0, read 1, enter state s1, write 1, move Right  
e. Using 5: at s1, read 1, enter state s2, write 0, move Left  
f. Using 7: at s2, read 1, enter state s3, write 0, move Right

Halt: No 5-tuple with (s3, 0)
</font>
</td>
</tr>
</table>


---
26 The Churchâ€“Turing Thesis
---


Given any problem that can be solved with an effective algorithm, there is a Turing
machine that can solve this problem. 

The reason this is called a thesis rather than a theorem is that
the concept of solvability by an effective algorithm is informal and imprecise, as opposed to the
notion of solvability by a Turing machine, which is formal and precise.


---
27 Computational Complexity, Computability, and Decidability
---


A decision problem asks whether statements from a particular class of statements are true.
Decision problems are also known as yes-or-no problems.

Is n prime? yes-or-no

When there is an effective algorithm that decides whether instances of a
decision problem are true, we say that this problem is *solvable* or *decidable*



---
28 Halting Problem
---


The halting problem is the decision problem that asks whether a Turing machine T eventually
halts when given an input string x.

The halting problem is an **unsolvable decision problem**. That is, no Turing machine exists
that, when given an encoding of a Turing machine T and its input string x as input, can
determine whether T eventually halts when started with x written on its tape

Dr Seuss proof of halting problem: https://ebiquity.umbc.edu/blogger/2008/01/19/how-dr-suess-would-prove-the-halting-problem-undecidable/




